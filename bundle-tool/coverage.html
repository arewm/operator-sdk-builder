
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/cmd/generate-related-images.go (5.3%)</option>
				
				<option value="file1">github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/cmd/main.go (0.0%)</option>
				
				<option value="file2">github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/cmd/snapshot.go (6.1%)</option>
				
				<option value="file3">github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/bundle/analyzer.go (18.9%)</option>
				
				<option value="file4">github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/provenance/verifier.go (0.0%)</option>
				
				<option value="file5">github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/snapshot/generator.go (71.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/bundle"
        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/resolver"
        "github.com/operator-framework/operator-manifest-tools/pkg/imagename"
        "github.com/operator-framework/operator-manifest-tools/pkg/pullspec"
        "github.com/spf13/cobra"
)

var generateRelatedImagesCmd = &amp;cobra.Command{
        Use:   "generate-related-images [csv-file-or-directory]",
        Short: "Generate and update relatedImages in ClusterServiceVersion",
        Long: `Generate and update the relatedImages section in a ClusterServiceVersion YAML file 
by extracting image references from deployment containers and optionally resolving them using 
ICSP/IDMS policies.

This ensures all deployment images are properly listed in spec.relatedImages.

If a directory is provided, it will search for CSV files in the manifests subdirectory.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                target := args[0]
                icspFile, _ := cmd.Flags().GetString("icsp")
                idmsFile, _ := cmd.Flags().GetString("idms")
                mirrorPolicyFile, _ := cmd.Flags().GetString("mirror-policy")
                dryRun, _ := cmd.Flags().GetBool("dry-run")

                // Use operator-manifest-tools to extract images from CSV
                var csvDir string
                info, err := os.Stat(target)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to stat target: %w", err)
                }</span>

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        // It's a directory - look for manifests subdirectory
                        manifestsDir := filepath.Join(target, "manifests")
                        if _, err := os.Stat(manifestsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return fmt.Errorf("manifests directory not found in %s", target)
                        }</span>
                        <span class="cov0" title="0">csvDir = manifestsDir</span>
                } else<span class="cov0" title="0"> {
                        // It's a file - use its directory
                        csvDir = filepath.Dir(target)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Processing CSV directory: %s\n", csvDir)

                // Load CSVs using operator-manifest-tools
                csvs, err := pullspec.FromDirectory(csvDir, pullspec.DefaultHeuristic)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load CSVs from directory: %w", err)
                }</span>

                <span class="cov0" title="0">if len(csvs) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no CSV files found in directory: %s", csvDir)
                }</span>

                <span class="cov0" title="0">if len(csvs) &gt; 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("multiple CSV files found, only one expected")
                }</span>

                <span class="cov0" title="0">csv := csvs[0]

                // Extract image references using operator-manifest-tools
                pullSpecs, err := csv.GetPullSpecs()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract image references from CSV: %w", err)
                }</span>

                <span class="cov0" title="0">if len(pullSpecs) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("No image references found in CSV")
                        return nil
                }</span>

                <span class="cov0" title="0">fmt.Printf("Found %d image references in CSV\n", len(pullSpecs))

                // Convert pullspecs to our ImageReference format
                var imageRefs []bundle.ImageReference
                for _, ps := range pullSpecs </span><span class="cov0" title="0">{
                        imageRefs = append(imageRefs, bundle.ImageReference{
                                Image: ps.String(),
                                Name:  ps.Repo,
                        })
                }</span>

                // Setup image resolver (optional)
                <span class="cov0" title="0">var imageResolver *resolver.ImageResolver
                hasMirrorPolicy := false

                if mirrorPolicyFile != "" || icspFile != "" || idmsFile != "" </span><span class="cov0" title="0">{
                        imageResolver = resolver.NewImageResolver()
                        hasMirrorPolicy = true

                        // Load mirror policy (unified approach)
                        if mirrorPolicyFile != "" </span><span class="cov0" title="0">{
                                if err := imageResolver.LoadMirrorPolicy(mirrorPolicyFile); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to load mirror policy: %w", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Backward compatibility: Load ICSP if provided
                                if icspFile != "" </span><span class="cov0" title="0">{
                                        if err := imageResolver.LoadICSP(icspFile); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to load ICSP: %w", err)
                                        }</span>
                                }

                                // Load IDMS if provided
                                <span class="cov0" title="0">if idmsFile != "" </span><span class="cov0" title="0">{
                                        if err := imageResolver.LoadIDMS(idmsFile); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to load IDMS: %w", err)
                                        }</span>
                                }
                        }
                }

                // Resolve image references (optional)
                <span class="cov0" title="0">var resolvedRefs []bundle.ImageReference
                if hasMirrorPolicy </span><span class="cov0" title="0">{
                        var err error
                        resolvedRefs, err = imageResolver.ResolveImageReferences(imageRefs)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to resolve image references: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // No mirror policy - use original images
                        resolvedRefs = imageRefs
                }</span>

                // Create replacement map for resolved images
                <span class="cov0" title="0">replacements := make(map[imagename.ImageName]imagename.ImageName)
                var changes []ImageChange
                
                if hasMirrorPolicy </span><span class="cov0" title="0">{
                        fmt.Printf("Image mapping summary: %+v\n", imageResolver.GetMappingSummary())
                        
                        // Create replacements for resolved images
                        for i, orig := range imageRefs </span><span class="cov0" title="0">{
                                if i &lt; len(resolvedRefs) &amp;&amp; orig.Image != resolvedRefs[i].Image </span><span class="cov0" title="0">{
                                        changes = append(changes, ImageChange{
                                                Original: orig.Image,
                                                Updated:  resolvedRefs[i].Image,
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        fmt.Println("No mirror policy provided - using original image references")
                }</span>

                // Update relatedImages in CSV using operator-manifest-tools
                <span class="cov0" title="0">err = csv.SetRelatedImages()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set related images in CSV: %w", err)
                }</span>

                // Apply image replacements if there are any
                <span class="cov0" title="0">if len(changes) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Made %d changes:\n", len(changes))
                        for _, change := range changes </span><span class="cov0" title="0">{
                                fmt.Printf("  %s -&gt; %s\n", change.Original, change.Updated)
                        }</span>
                        
                        // Create replacement map
                        <span class="cov0" title="0">for _, change := range changes </span><span class="cov0" title="0">{
                                // Find the corresponding pullspec and create replacement
                                for _, ps := range pullSpecs </span><span class="cov0" title="0">{
                                        if ps.String() == change.Original </span><span class="cov0" title="0">{
                                                // Parse new image name and add to replacement map
                                                newImage := imagename.Parse(change.Updated)
                                                replacements[*ps] = *newImage
                                                break</span>
                                        }
                                }
                        }
                        
                        // Apply replacements
                        <span class="cov0" title="0">err = csv.ReplacePullSpecs(replacements)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to replace pull specs in CSV: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("No changes needed - relatedImages already up to date")
                        if !dryRun </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                        fmt.Println("Dry run mode - no changes written to file")
                        return nil
                }</span>

                // Write updated CSV back to file using operator-manifest-tools
                <span class="cov0" title="0">err = csv.Dump(nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write updated CSV: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Successfully updated CSV file\n")
                return nil</span>
        },
}

type ImageChange struct {
        Original string
        Updated  string
}


func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(generateRelatedImagesCmd)

        generateRelatedImagesCmd.Flags().StringP("mirror-policy", "m", "", "Path to mirror policy YAML file (ICSP or IDMS)")
        generateRelatedImagesCmd.Flags().StringP("icsp", "i", "", "Path to ImageContentSourcePolicy YAML file (deprecated, use --mirror-policy)")
        generateRelatedImagesCmd.Flags().StringP("idms", "d", "", "Path to ImageDigestMirrorSet YAML file (deprecated, use --mirror-policy)")
        generateRelatedImagesCmd.Flags().Bool("dry-run", false, "Show changes without modifying files")
}</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:   "bundle-tool",
        Short: "A tool for working with OLM bundles and creating Konflux snapshots",
        Long: `bundle-tool is a comprehensive toolkit for OLM bundle operations including:
- Creating Konflux snapshots from bundle images
- Manipulating bundle image references
- Generating relatedImages sections
- Converting image references between registries`,
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "strings"

        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/bundle"
        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/provenance"
        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/resolver"
        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/snapshot"
        "github.com/spf13/cobra"
)

var snapshotCmd = &amp;cobra.Command{
        Use:   "snapshot [bundle-image]",
        Short: "Create a Konflux snapshot from an OLM bundle image",
        Long: `Analyze an OLM bundle image, resolve image references using ICSP/IDMS policies,
verify provenance, and generate a Konflux snapshot YAML.`,
        Args: cobra.ExactArgs(1),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                bundleImage := args[0]
                icspFile, _ := cmd.Flags().GetString("icsp")
                idmsFile, _ := cmd.Flags().GetString("idms")
                mirrorPolicyFile, _ := cmd.Flags().GetString("mirror-policy")
                verifyProvenance, _ := cmd.Flags().GetBool("verify-provenance")
                outputFile, _ := cmd.Flags().GetString("output")

                // Step 1: Extract image references from bundle
                analyzer := bundle.NewBundleAnalyzer()
                imageRefs, err := analyzer.ExtractImageReferences(context.Background(), bundleImage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to extract image references: %w", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Found %d image references in bundle %s:\n", len(imageRefs), bundleImage)

                // Step 2: Resolve image references using ICSP/IDMS
                imageResolver := resolver.NewImageResolver()

                // Load mirror policy (unified approach)
                if mirrorPolicyFile != "" </span><span class="cov0" title="0">{
                        if err := imageResolver.LoadMirrorPolicy(mirrorPolicyFile); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to load mirror policy: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Backward compatibility: Load ICSP if provided
                        if icspFile != "" </span><span class="cov0" title="0">{
                                if err := imageResolver.LoadICSP(icspFile); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to load ICSP: %w", err)
                                }</span>
                        }

                        // Load IDMS if provided
                        <span class="cov0" title="0">if idmsFile != "" </span><span class="cov0" title="0">{
                                if err := imageResolver.LoadIDMS(idmsFile); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to load IDMS: %w", err)
                                }</span>
                        }
                }

                // Resolve the image references
                <span class="cov0" title="0">resolvedRefs, err := imageResolver.ResolveImageReferences(imageRefs)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve image references: %w", err)
                }</span>

                // Step 3: Verify provenance if requested
                <span class="cov0" title="0">var provenanceResults []provenance.ProvenanceInfo
                if verifyProvenance </span><span class="cov0" title="0">{
                        fmt.Println("Verifying image provenance...")
                        verifier := provenance.NewProvenanceVerifier()
                        verifier.SetVerbose(true)

                        provenanceResults, err = verifier.VerifyProvenance(context.Background(), resolvedRefs)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to verify provenance: %w", err)
                        }</span>

                        <span class="cov0" title="0">fmt.Printf("Provenance verification summary: %+v\n", verifier.GetVerificationSummary(provenanceResults))</span>
                }

                // Display results
                <span class="cov0" title="0">fmt.Printf("Mapping summary: %+v\n", imageResolver.GetMappingSummary())
                fmt.Printf("Resolved image references:\n")
                for i, ref := range resolvedRefs </span><span class="cov0" title="0">{
                        fmt.Printf("  %d. Original: %s\n", i+1, imageRefs[i].Image)
                        fmt.Printf("     Resolved: %s\n", ref.Image)
                        if ref.Name != "" </span><span class="cov0" title="0">{
                                fmt.Printf("     Name: %s\n", ref.Name)
                        }</span>
                        <span class="cov0" title="0">if ref.Digest != "" </span><span class="cov0" title="0">{
                                fmt.Printf("     Digest: %s\n", ref.Digest)
                        }</span>

                        // Display provenance info if available
                        <span class="cov0" title="0">if verifyProvenance &amp;&amp; i &lt; len(provenanceResults) </span><span class="cov0" title="0">{
                                prov := provenanceResults[i]
                                fmt.Printf("     Provenance verified: %t\n", prov.Verified)
                                if prov.SourceRepo != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("     Source repo: %s\n", prov.SourceRepo)
                                }</span>
                                <span class="cov0" title="0">if prov.SourceCommit != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("     Source commit: %s\n", prov.SourceCommit)
                                }</span>
                                <span class="cov0" title="0">if prov.Error != "" </span><span class="cov0" title="0">{
                                        fmt.Printf("     Provenance error: %s\n", prov.Error)
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                // Step 4: Generate Konflux Snapshot
                <span class="cov0" title="0">appName := extractAppNameFromBundle(bundleImage)
                namespace := "default" // TODO: make this configurable

                generator := snapshot.NewSnapshotGenerator(appName, namespace)
                konfluxSnapshot, err := generator.GenerateSnapshot(resolvedRefs, provenanceResults, bundleImage)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate snapshot: %w", err)
                }</span>

                // Deduplicate components and validate
                <span class="cov0" title="0">generator.DeduplicateComponents(konfluxSnapshot)
                if err := generator.ValidateSnapshot(konfluxSnapshot); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generated snapshot is invalid: %w", err)
                }</span>

                // Convert to YAML
                <span class="cov0" title="0">yamlOutput, err := generator.ToYAML(konfluxSnapshot)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to convert snapshot to YAML: %w", err)
                }</span>

                // Output to file or stdout
                <span class="cov0" title="0">if outputFile != "" </span><span class="cov0" title="0">{
                        if err := os.WriteFile(outputFile, yamlOutput, 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write snapshot to file %s: %w", outputFile, err)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Snapshot written to: %s\n", outputFile)</span>
                } else<span class="cov0" title="0"> {
                        fmt.Println("Generated Konflux Snapshot:")
                        fmt.Println("---")
                        fmt.Print(string(yamlOutput))
                }</span>

                <span class="cov0" title="0">return nil</span>
        },
}

// extractAppNameFromBundle extracts a suitable application name from the bundle image reference
func extractAppNameFromBundle(bundleImage string) string <span class="cov0" title="0">{
        // Remove transport prefix if present
        if idx := strings.Index(bundleImage, "://"); idx != -1 </span><span class="cov0" title="0">{
                bundleImage = bundleImage[idx+3:]
        }</span>

        // Split by / to get components
        <span class="cov0" title="0">parts := strings.Split(bundleImage, "/")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return "bundle-app"
        }</span>

        // Get the last part (image name)
        <span class="cov0" title="0">imageName := parts[len(parts)-1]

        // Remove tag/digest
        if idx := strings.Index(imageName, ":"); idx != -1 </span><span class="cov0" title="0">{
                imageName = imageName[:idx]
        }</span>
        <span class="cov0" title="0">if idx := strings.Index(imageName, "@"); idx != -1 </span><span class="cov0" title="0">{
                imageName = imageName[:idx]
        }</span>

        // Clean the name to be a valid Kubernetes name
        <span class="cov0" title="0">imageName = strings.ToLower(imageName)
        imageName = strings.ReplaceAll(imageName, "_", "-")
        imageName = strings.ReplaceAll(imageName, ".", "-")

        // Remove invalid characters
        var cleanName strings.Builder
        for i, r := range imageName </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || (r == '-' &amp;&amp; i &gt; 0 &amp;&amp; i &lt; len(imageName)-1) </span><span class="cov0" title="0">{
                        cleanName.WriteRune(r)
                }</span>
        }

        <span class="cov0" title="0">result := strings.Trim(cleanName.String(), "-")
        if result == "" </span><span class="cov0" title="0">{
                result = "bundle-app"
        }</span>

        <span class="cov0" title="0">return result</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(snapshotCmd)

        snapshotCmd.Flags().StringP("mirror-policy", "m", "", "Path to mirror policy YAML file (ICSP or IDMS)")
        snapshotCmd.Flags().StringP("icsp", "i", "", "Path to ImageContentSourcePolicy YAML file (deprecated, use --mirror-policy)")
        snapshotCmd.Flags().StringP("idms", "d", "", "Path to ImageDigestMirrorSet YAML file (deprecated, use --mirror-policy)")
        snapshotCmd.Flags().StringP("output", "o", "", "Output file for generated snapshot (default: stdout)")
        snapshotCmd.Flags().Bool("verify-provenance", true, "Verify image provenance using cosign")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package bundle

import (
        "archive/tar"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "path/filepath"
        "strings"

        "github.com/containers/image/v5/transports/alltransports"
        "github.com/containers/image/v5/types"
        "github.com/opencontainers/go-digest"
        "github.com/opencontainers/image-spec/specs-go/v1"
        "gopkg.in/yaml.v3"
)

type ImageReference struct {
        Name   string `json:"name,omitempty"`
        Image  string `json:"image"`
        Digest string `json:"digest,omitempty"`
}

type RelatedImage struct {
        Name  string `yaml:"name,omitempty"`
        Image string `yaml:"image"`
}

type ClusterServiceVersion struct {
        APIVersion string `yaml:"apiVersion"`
        Kind       string `yaml:"kind"`
        Metadata   struct {
                Name string `yaml:"name"`
        } `yaml:"metadata"`
        Spec struct {
                RelatedImages []RelatedImage `yaml:"relatedImages,omitempty"`
                Install       struct {
                        Spec struct {
                                Deployments []struct {
                                        Name string `yaml:"name"`
                                        Spec struct {
                                                Template struct {
                                                        Spec struct {
                                                                Containers []struct {
                                                                        Name  string `yaml:"name"`
                                                                        Image string `yaml:"image"`
                                                                } `yaml:"containers"`
                                                                InitContainers []struct {
                                                                        Name  string `yaml:"name"`
                                                                        Image string `yaml:"image"`
                                                                } `yaml:"initContainers,omitempty"`
                                                        } `yaml:"spec"`
                                                } `yaml:"template"`
                                        } `yaml:"spec"`
                                } `yaml:"deployments"`
                        } `yaml:"spec"`
                } `yaml:"install"`
        } `yaml:"spec"`
}

type BundleAnalyzer struct {
        systemContext *types.SystemContext
}

func NewBundleAnalyzer() *BundleAnalyzer <span class="cov8" title="1">{
        return &amp;BundleAnalyzer{
                systemContext: &amp;types.SystemContext{},
        }
}</span>

func (ba *BundleAnalyzer) ExtractImageReferences(ctx context.Context, bundleImage string) ([]ImageReference, error) <span class="cov0" title="0">{
        // Add docker:// prefix if no transport is specified
        if !strings.Contains(bundleImage, "://") </span><span class="cov0" title="0">{
                bundleImage = "docker://" + bundleImage
        }</span>

        <span class="cov0" title="0">srcRef, err := alltransports.ParseImageName(bundleImage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse bundle image reference %q: %w", bundleImage, err)
        }</span>

        // Create an ImageSource to access GetBlob method
        <span class="cov0" title="0">srcImgSource, err := srcRef.NewImageSource(ctx, ba.systemContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create source image source: %w", err)
        }</span>
        <span class="cov0" title="0">defer srcImgSource.Close()

        // Also create an Image to easily get layer information
        srcImg, err := srcRef.NewImage(ctx, ba.systemContext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create source image: %w", err)
        }</span>
        <span class="cov0" title="0">defer srcImg.Close()

        layerInfos := srcImg.LayerInfos()
        if len(layerInfos) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("bundle image has no layers")
        }</span>

        <span class="cov0" title="0">var allImageRefs []ImageReference

        for i, layerInfo := range layerInfos </span><span class="cov0" title="0">{
                // Use ImageSource.GetBlob() instead of Image.GetBlob()
                layerReader, _, err := srcImgSource.GetBlob(ctx, layerInfo, nil)
                if err != nil </span><span class="cov0" title="0">{
                        // Continue processing other layers if one fails
                        fmt.Printf("Warning: failed to read layer %d: %v\n", i, err)
                        continue</span>
                }

                <span class="cov0" title="0">imageRefs, err := ba.extractImageReferencesFromTar(layerReader)
                layerReader.Close()
                if err != nil </span><span class="cov0" title="0">{
                        // Continue processing other layers if one fails
                        fmt.Printf("Warning: failed to extract references from layer %d: %v\n", i, err)
                        continue</span>
                }

                <span class="cov0" title="0">allImageRefs = append(allImageRefs, imageRefs...)</span>
        }

        <span class="cov0" title="0">return ba.deduplicateImageReferences(allImageRefs), nil</span>
}

func (ba *BundleAnalyzer) extractImageReferencesFromTar(tarReader io.ReadCloser) ([]ImageReference, error) <span class="cov0" title="0">{
        var imageRefs []ImageReference

        tr := tar.NewReader(tarReader)
        for </span><span class="cov0" title="0">{
                header, err := tr.Next()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read tar header: %w", err)
                }</span>

                <span class="cov0" title="0">if header.Typeflag != tar.TypeReg </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if !isManifestFile(header.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">content, err := io.ReadAll(tr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read file content: %w", err)
                }</span>

                <span class="cov0" title="0">refs, err := ba.extractImageReferencesFromManifest(content, header.Name)
                if err != nil </span><span class="cov0" title="0">{
                        // Log warning but continue processing other files
                        fmt.Printf("Warning: failed to parse manifest %s: %v\n", header.Name, err)
                        continue</span>
                }

                <span class="cov0" title="0">imageRefs = append(imageRefs, refs...)</span>
        }

        <span class="cov0" title="0">return imageRefs, nil</span>
}

func (ba *BundleAnalyzer) extractImageReferencesFromManifest(content []byte, filename string) ([]ImageReference, error) <span class="cov0" title="0">{
        // First try to parse as a generic Kubernetes object to check the Kind
        var obj struct {
                Kind string `yaml:"kind"`
        }
        if err := yaml.Unmarshal(content, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal manifest: %w", err)
        }</span>

        // Only process ClusterServiceVersion manifests
        <span class="cov0" title="0">if obj.Kind != "ClusterServiceVersion" </span><span class="cov0" title="0">{
                return []ImageReference{}, nil // Return empty list, not an error
        }</span>

        <span class="cov0" title="0">var csv ClusterServiceVersion
        if err := yaml.Unmarshal(content, &amp;csv); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal CSV: %w", err)
        }</span>

        <span class="cov0" title="0">var imageRefs []ImageReference

        // Extract from spec.relatedImages
        for _, relatedImage := range csv.Spec.RelatedImages </span><span class="cov0" title="0">{
                if relatedImage.Image != "" </span><span class="cov0" title="0">{
                        imageRefs = append(imageRefs, ImageReference{
                                Name:   relatedImage.Name,
                                Image:  relatedImage.Image,
                                Digest: extractDigest(relatedImage.Image),
                        })
                }</span>
        }

        // Extract from deployment containers
        <span class="cov0" title="0">for _, deployment := range csv.Spec.Install.Spec.Deployments </span><span class="cov0" title="0">{
                for _, container := range deployment.Spec.Template.Spec.Containers </span><span class="cov0" title="0">{
                        if container.Image != "" </span><span class="cov0" title="0">{
                                name := container.Name
                                if name == "" </span><span class="cov0" title="0">{
                                        name = fmt.Sprintf("%s-container", deployment.Name)
                                }</span>
                                <span class="cov0" title="0">imageRefs = append(imageRefs, ImageReference{
                                        Name:   name,
                                        Image:  container.Image,
                                        Digest: extractDigest(container.Image),
                                })</span>
                        }
                }
                <span class="cov0" title="0">for _, initContainer := range deployment.Spec.Template.Spec.InitContainers </span><span class="cov0" title="0">{
                        if initContainer.Image != "" </span><span class="cov0" title="0">{
                                name := initContainer.Name
                                if name == "" </span><span class="cov0" title="0">{
                                        name = fmt.Sprintf("%s-init-container", deployment.Name)
                                }</span>
                                <span class="cov0" title="0">imageRefs = append(imageRefs, ImageReference{
                                        Name:   name,
                                        Image:  initContainer.Image,
                                        Digest: extractDigest(initContainer.Image),
                                })</span>
                        }
                }
        }

        <span class="cov0" title="0">return imageRefs, nil</span>
}

func (ba *BundleAnalyzer) deduplicateImageReferences(refs []ImageReference) []ImageReference <span class="cov8" title="1">{
        seen := make(map[string]bool)
        var result []ImageReference

        for _, ref := range refs </span><span class="cov8" title="1">{
                key := ref.Image
                if !seen[key] </span><span class="cov8" title="1">{
                        seen[key] = true
                        result = append(result, ref)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func isManifestFile(filename string) bool <span class="cov8" title="1">{
        ext := filepath.Ext(filename)
        basename := filepath.Base(filename)

        // Check if it's in manifests directory and has yaml extension
        hasYamlExt := ext == ".yaml" || ext == ".yml"
        inManifestsDir := strings.Contains(filename, "manifests/")

        // Skip metadata files and annotations
        if strings.HasPrefix(basename, ".") || strings.Contains(basename, "annotations") </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return inManifestsDir &amp;&amp; hasYamlExt</span>
}

func (ba *BundleAnalyzer) getLayerInfosFromManifest(manifestBlob []byte, manifestType string) ([]types.BlobInfo, error) <span class="cov0" title="0">{
        var layerInfos []types.BlobInfo

        switch manifestType </span>{
        case v1.MediaTypeImageManifest:<span class="cov0" title="0">
                var manifest v1.Manifest
                if err := json.Unmarshal(manifestBlob, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse OCI manifest: %w", err)
                }</span>

                <span class="cov0" title="0">for _, layer := range manifest.Layers </span><span class="cov0" title="0">{
                        layerInfos = append(layerInfos, types.BlobInfo{
                                Digest: digest.Digest(layer.Digest),
                                Size:   layer.Size,
                        })
                }</span>

        case "application/vnd.docker.distribution.manifest.v2+json":<span class="cov0" title="0">
                var manifest struct {
                        Layers []struct {
                                Digest string `json:"digest"`
                                Size   int64  `json:"size"`
                        } `json:"layers"`
                }
                if err := json.Unmarshal(manifestBlob, &amp;manifest); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse Docker manifest v2: %w", err)
                }</span>

                <span class="cov0" title="0">for _, layer := range manifest.Layers </span><span class="cov0" title="0">{
                        layerInfos = append(layerInfos, types.BlobInfo{
                                Digest: digest.Digest(layer.Digest),
                                Size:   layer.Size,
                        })
                }</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported manifest type: %s", manifestType)</span>
        }

        <span class="cov0" title="0">return layerInfos, nil</span>
}

func extractDigest(image string) string <span class="cov8" title="1">{
        if strings.Contains(image, "@sha256:") </span><span class="cov8" title="1">{
                parts := strings.Split(image, "@")
                if len(parts) == 2 </span><span class="cov8" title="1">{
                        return parts[1]
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package provenance

import (
        "context"
        "encoding/json"
        "fmt"
        "os/exec"
        "strings"

        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/bundle"
)

// ProvenanceInfo contains source information extracted from provenance attestations
type ProvenanceInfo struct {
        ImageRef      string            `json:"image_ref"`
        SourceRepo    string            `json:"source_repo,omitempty"`
        SourceCommit  string            `json:"source_commit,omitempty"`
        BuildPlatform string            `json:"build_platform,omitempty"`
        Verified      bool              `json:"verified"`
        Error         string            `json:"error,omitempty"`
        Metadata      map[string]string `json:"metadata,omitempty"`
}

// SLSAAttestation represents a simplified SLSA provenance structure
type SLSAAttestation struct {
        PredicateType string `json:"predicateType"`
        Predicate     struct {
                Builder struct {
                        ID string `json:"id"`
                } `json:"builder"`
                BuildDefinition struct {
                        ExternalParameters   map[string]interface{} `json:"externalParameters"`
                        ResolvedDependencies []struct {
                                URI    string            `json:"uri"`
                                Digest map[string]string `json:"digest"`
                        } `json:"resolvedDependencies"`
                } `json:"buildDefinition"`
                RunDetails struct {
                        Builder struct {
                                ID string `json:"id"`
                        } `json:"builder"`
                        Metadata struct {
                                InvocationID string `json:"invocationId"`
                        } `json:"metadata"`
                } `json:"runDetails"`
        } `json:"predicate"`
}

// ProvenanceVerifier handles verification of image provenance using cosign
type ProvenanceVerifier struct {
        cosignPath string
        verbose    bool
}

// NewProvenanceVerifier creates a new ProvenanceVerifier
func NewProvenanceVerifier() *ProvenanceVerifier <span class="cov0" title="0">{
        return &amp;ProvenanceVerifier{
                cosignPath: "cosign", // assume cosign is in PATH
                verbose:    false,
        }
}</span>

// SetCosignPath sets a custom path to the cosign binary
func (pv *ProvenanceVerifier) SetCosignPath(path string) <span class="cov0" title="0">{
        pv.cosignPath = path
}</span>

// SetVerbose enables verbose output
func (pv *ProvenanceVerifier) SetVerbose(verbose bool) <span class="cov0" title="0">{
        pv.verbose = verbose
}</span>

// VerifyProvenance verifies provenance for a list of image references
func (pv *ProvenanceVerifier) VerifyProvenance(ctx context.Context, imageRefs []bundle.ImageReference) ([]ProvenanceInfo, error) <span class="cov0" title="0">{
        var results []ProvenanceInfo

        for _, ref := range imageRefs </span><span class="cov0" title="0">{
                info := ProvenanceInfo{
                        ImageRef: ref.Image,
                        Metadata: make(map[string]string),
                }

                // Try to verify and extract provenance
                if err := pv.verifyImageProvenance(ctx, ref.Image, &amp;info); err != nil </span><span class="cov0" title="0">{
                        info.Verified = false
                        info.Error = err.Error()
                        if pv.verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: provenance verification failed for %s: %v\n", ref.Image, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        info.Verified = true
                }</span>

                <span class="cov0" title="0">results = append(results, info)</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// verifyImageProvenance verifies a single image's provenance using cosign
func (pv *ProvenanceVerifier) verifyImageProvenance(ctx context.Context, imageRef string, info *ProvenanceInfo) error <span class="cov0" title="0">{
        // First check if cosign is available
        if !pv.isCosignAvailable() </span><span class="cov0" title="0">{
                return fmt.Errorf("cosign binary not found in PATH")
        }</span>

        // Try to verify attestation
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, pv.cosignPath, "verify-attestation",
                "--type", "slsaprovenance",
                "--certificate-identity-regexp", ".*",
                "--certificate-oidc-issuer-regexp", ".*",
                imageRef)

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                // If verification fails, it might be because the image isn't signed
                // or doesn't have provenance. This is not necessarily an error.
                return fmt.Errorf("no valid provenance attestation found")
        }</span>

        // Parse the SLSA attestation
        <span class="cov0" title="0">if err := pv.parseProvenance(output, info); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse provenance: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// parseProvenance extracts information from SLSA provenance attestation
func (pv *ProvenanceVerifier) parseProvenance(attestationJSON []byte, info *ProvenanceInfo) error <span class="cov0" title="0">{
        lines := strings.Split(string(attestationJSON), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || !strings.HasPrefix(line, "{") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var attestation SLSAAttestation
                if err := json.Unmarshal([]byte(line), &amp;attestation); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip lines that aren't valid JSON
                }

                // Extract source repository information
                <span class="cov0" title="0">if buildDef := attestation.Predicate.BuildDefinition; len(buildDef.ResolvedDependencies) &gt; 0 </span><span class="cov0" title="0">{
                        for _, dep := range buildDef.ResolvedDependencies </span><span class="cov0" title="0">{
                                if strings.Contains(dep.URI, "git+") </span><span class="cov0" title="0">{
                                        info.SourceRepo = dep.URI
                                        if sha, ok := dep.Digest["sha1"]; ok </span><span class="cov0" title="0">{
                                                info.SourceCommit = sha
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }

                // Extract build platform
                <span class="cov0" title="0">if attestation.Predicate.Builder.ID != "" </span><span class="cov0" title="0">{
                        info.BuildPlatform = attestation.Predicate.Builder.ID
                }</span>

                // Extract external parameters as metadata
                <span class="cov0" title="0">if extParams := attestation.Predicate.BuildDefinition.ExternalParameters; len(extParams) &gt; 0 </span><span class="cov0" title="0">{
                        for key, value := range extParams </span><span class="cov0" title="0">{
                                if strVal, ok := value.(string); ok </span><span class="cov0" title="0">{
                                        info.Metadata[key] = strVal
                                }</span>
                        }
                }

                <span class="cov0" title="0">break</span> // Process only the first valid attestation
        }

        <span class="cov0" title="0">return nil</span>
}

// isCosignAvailable checks if cosign binary is available
func (pv *ProvenanceVerifier) isCosignAvailable() bool <span class="cov0" title="0">{
        cmd := exec.Command(pv.cosignPath, "version")
        return cmd.Run() == nil
}</span>

// GetVerificationSummary returns a summary of verification results
func (pv *ProvenanceVerifier) GetVerificationSummary(results []ProvenanceInfo) map[string]interface{} <span class="cov0" title="0">{
        total := len(results)
        verified := 0
        withSource := 0

        for _, result := range results </span><span class="cov0" title="0">{
                if result.Verified </span><span class="cov0" title="0">{
                        verified++
                }</span>
                <span class="cov0" title="0">if result.SourceRepo != "" </span><span class="cov0" title="0">{
                        withSource++
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "total_images":       total,
                "verified_images":    verified,
                "images_with_source": withSource,
                "verification_rate":  float64(verified) / float64(total) * 100,
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package snapshot

import (
        "fmt"
        "strings"
        "time"

        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/bundle"
        "github.com/konflux-ci-forks/operator-sdk-builder/bundle-tool/pkg/provenance"
        "gopkg.in/yaml.v3"
)

// KonfluxSnapshot represents a Konflux Snapshot resource
type KonfluxSnapshot struct {
        APIVersion string           `yaml:"apiVersion"`
        Kind       string           `yaml:"kind"`
        Metadata   SnapshotMetadata `yaml:"metadata"`
        Spec       SnapshotSpec     `yaml:"spec"`
}

type SnapshotMetadata struct {
        Name        string            `yaml:"name"`
        Namespace   string            `yaml:"namespace,omitempty"`
        Labels      map[string]string `yaml:"labels,omitempty"`
        Annotations map[string]string `yaml:"annotations,omitempty"`
}

type SnapshotSpec struct {
        Application string              `yaml:"application"`
        Components  []SnapshotComponent `yaml:"components"`
}

type SnapshotComponent struct {
        Name           string           `yaml:"name"`
        ContainerImage string           `yaml:"containerImage"`
        Source         *ComponentSource `yaml:"source,omitempty"`
}

type ComponentSource struct {
        Git *GitSource `yaml:"git,omitempty"`
}

type GitSource struct {
        URL      string `yaml:"url"`
        Revision string `yaml:"revision,omitempty"`
}

// SnapshotGenerator handles generation of Konflux Snapshot YAML
type SnapshotGenerator struct {
        appName   string
        namespace string
}

// NewSnapshotGenerator creates a new SnapshotGenerator
func NewSnapshotGenerator(appName, namespace string) *SnapshotGenerator <span class="cov8" title="1">{
        return &amp;SnapshotGenerator{
                appName:   appName,
                namespace: namespace,
        }
}</span>

// GenerateSnapshot creates a Konflux Snapshot from image references and provenance info
func (sg *SnapshotGenerator) GenerateSnapshot(
        imageRefs []bundle.ImageReference,
        provenanceResults []provenance.ProvenanceInfo,
        bundleImage string,
) (*KonfluxSnapshot, error) <span class="cov8" title="1">{

        timestamp := time.Now().Format("20060102-150405")
        snapshotName := fmt.Sprintf("%s-bundle-snapshot-%s", sg.appName, timestamp)

        snapshot := &amp;KonfluxSnapshot{
                APIVersion: "appstudio.redhat.com/v1alpha1",
                Kind:       "Snapshot",
                Metadata: SnapshotMetadata{
                        Name:      snapshotName,
                        Namespace: sg.namespace,
                        Labels: map[string]string{
                                "appstudio.openshift.io/application": sg.appName,
                                "bundle-tool.konflux.io/source":      "bundle-analysis",
                        },
                        Annotations: map[string]string{
                                "bundle-tool.konflux.io/source-bundle": bundleImage,
                                "bundle-tool.konflux.io/generated-at":  time.Now().Format(time.RFC3339),
                        },
                },
                Spec: SnapshotSpec{
                        Application: sg.appName,
                        Components:  []SnapshotComponent{},
                },
        }

        // Convert image references to snapshot components
        for i, ref := range imageRefs </span><span class="cov8" title="1">{
                component := SnapshotComponent{
                        Name:           sg.generateComponentName(ref),
                        ContainerImage: ref.Image,
                }

                // Add source information from provenance if available
                if i &lt; len(provenanceResults) &amp;&amp; provenanceResults[i].Verified </span><span class="cov8" title="1">{
                        prov := provenanceResults[i]
                        if prov.SourceRepo != "" </span><span class="cov8" title="1">{
                                component.Source = &amp;ComponentSource{
                                        Git: &amp;GitSource{
                                                URL:      sg.cleanGitURL(prov.SourceRepo),
                                                Revision: prov.SourceCommit,
                                        },
                                }
                        }</span>
                }

                <span class="cov8" title="1">snapshot.Spec.Components = append(snapshot.Spec.Components, component)</span>
        }

        <span class="cov8" title="1">return snapshot, nil</span>
}

// generateComponentName creates a valid Kubernetes resource name from an image reference
func (sg *SnapshotGenerator) generateComponentName(ref bundle.ImageReference) string <span class="cov8" title="1">{
        name := ref.Name
        if name == "" </span><span class="cov0" title="0">{
                // Extract component name from image reference
                parts := strings.Split(ref.Image, "/")
                imageName := parts[len(parts)-1]

                // Remove tag/digest
                if idx := strings.Index(imageName, ":"); idx != -1 </span><span class="cov0" title="0">{
                        imageName = imageName[:idx]
                }</span>
                <span class="cov0" title="0">if idx := strings.Index(imageName, "@"); idx != -1 </span><span class="cov0" title="0">{
                        imageName = imageName[:idx]
                }</span>

                <span class="cov0" title="0">name = imageName</span>
        }

        // Ensure valid Kubernetes name
        <span class="cov8" title="1">name = strings.ToLower(name)
        name = strings.ReplaceAll(name, "_", "-")
        name = strings.ReplaceAll(name, ".", "-")

        // Remove invalid characters and ensure it starts/ends with alphanumeric
        var cleanName strings.Builder
        for i, r := range name </span><span class="cov8" title="1">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || (r == '-' &amp;&amp; i &gt; 0 &amp;&amp; i &lt; len(name)-1) </span><span class="cov8" title="1">{
                        cleanName.WriteRune(r)
                }</span>
        }

        <span class="cov8" title="1">result := cleanName.String()
        if result == "" </span><span class="cov0" title="0">{
                result = "component"
        }</span>

        // Ensure it doesn't start or end with hyphen
        <span class="cov8" title="1">result = strings.Trim(result, "-")
        if result == "" </span><span class="cov0" title="0">{
                result = "component"
        }</span>

        <span class="cov8" title="1">return result</span>
}

// cleanGitURL converts provenance git URLs to standard format
func (sg *SnapshotGenerator) cleanGitURL(provenanceURL string) string <span class="cov8" title="1">{
        // Handle git+ prefix
        if strings.HasPrefix(provenanceURL, "git+") </span><span class="cov0" title="0">{
                provenanceURL = strings.TrimPrefix(provenanceURL, "git+")
        }</span>

        // Handle various URL formats
        <span class="cov8" title="1">if strings.HasPrefix(provenanceURL, "https://github.com/") </span><span class="cov8" title="1">{
                return provenanceURL
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(provenanceURL, "github.com/") </span><span class="cov0" title="0">{
                return "https://" + provenanceURL
        }</span>

        <span class="cov0" title="0">return provenanceURL</span>
}

// ToYAML converts the snapshot to YAML format
func (sg *SnapshotGenerator) ToYAML(snapshot *KonfluxSnapshot) ([]byte, error) <span class="cov0" title="0">{
        return yaml.Marshal(snapshot)
}</span>

// DeduplicateComponents removes duplicate components based on container image
func (sg *SnapshotGenerator) DeduplicateComponents(snapshot *KonfluxSnapshot) <span class="cov8" title="1">{
        seen := make(map[string]bool)
        var uniqueComponents []SnapshotComponent

        for _, component := range snapshot.Spec.Components </span><span class="cov8" title="1">{
                key := component.ContainerImage
                if !seen[key] </span><span class="cov8" title="1">{
                        seen[key] = true
                        uniqueComponents = append(uniqueComponents, component)
                }</span>
        }

        <span class="cov8" title="1">snapshot.Spec.Components = uniqueComponents</span>
}

// ValidateSnapshot performs basic validation on the generated snapshot
func (sg *SnapshotGenerator) ValidateSnapshot(snapshot *KonfluxSnapshot) error <span class="cov8" title="1">{
        if snapshot.Metadata.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("snapshot name cannot be empty")
        }</span>

        <span class="cov8" title="1">if snapshot.Spec.Application == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("application name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(snapshot.Spec.Components) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("snapshot must contain at least one component")
        }</span>

        // Validate component names
        <span class="cov8" title="1">for _, component := range snapshot.Spec.Components </span><span class="cov8" title="1">{
                if component.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("component name cannot be empty")
                }</span>
                <span class="cov8" title="1">if component.ContainerImage == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("component container image cannot be empty")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
